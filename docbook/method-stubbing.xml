<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude">
	<title>Method Stubbing</title>
	<section><title>Basic Method Stubbing</title>
		<para>
			The <function>Phake::when()</function> method is used to stub methods in Phake. As discussed in the introduction,
			stubbing allows an object method to be forced to return a particular value given a set of parameters. Similarly to
			<function>Phake::verify()</function>, <function>Phake::when()</function> accepts a mock object generated from
			<function>Phake::mock()</function> as its first parameter.
		</para>
		<para>
			Imagine I was in the process of building the next great online shopping cart. The first thing any
			good shopping cart allows is to be able to add items. The most important thing I want to know from
			the shopping cart is how much money in merchandise is in there. So, I need to make myself a
			<classname>ShoppingCart</classname> class. I also am going to need some class to define my items.
			I am more worried about the money right now and because of that I am keenly aware that any item
			in a shopping cart is going to have a price. So I will just create an interface to represent those
			items called <classname>Item</classname>. Now take a minute to marvel at the creativity of those
			names. Great, now check out the initial definitions for my objects.
		</para>
		<xi:include href="method-stubbing/simple-stubbing/order-v1.xml" />
		<para>
			So, I am furiously coding away at this fantastic new <classname>ShoppingCart</classname> class when I
			realize, I am doing it wrong! You see, a few years ago I went to this conference with a bunch of
			other geeky people to talk about how to make quality software. I am supposed to be writing unit
			tests. Here I am, a solid thirteen lines (not counting comments) of code into my awe inspiring
			new software and I haven't written a single test. I tell myself, "There's no better time to change
			than right now!" So I decide to start testing. After looking at the options I decide PHPUnit with
			this sweet new mock library called Phake is the way to go.
		</para>
		<para>
			My first test is going to be for the currently unimplemented <function>ShoppingCart::getSubTotal()</function>
			method. I already have a pretty good idea of what this function is going to need to do. It will
			need to look at all of the items in the cart, retrieve their price, add it all together and return
			the result. So, in my test I know I am going to need a fixture that sets up a shopping cart with
			a few items added. Then I am going to need a test that calls <function>ShoppingCart::getSubTotal()</function>
			and asserts that it returns a value equal to the price of the items I added to the cart. One catch
			though, I don't have any concrete instances of an Item. I wasn't even planning on doing any of
			that until tomorrow. I really want to just focus on the <classname>ShoppingCart</classname> class.
			Never fear, this is why I decided to use Phake. I remember reading about how it will allow me to
			quickly create instance of my classes and interfaces that I can set up stubs for so that method
			calls return predictable values. This project is all coming together and I am really excited.
		</para>
		<xi:include href="method-stubbing/simple-stubbing/ordertest-v1.xml" />
		<para>
			My test here shows a very basic use of Phake for creating method stubs. I am creating three different mock
			implementations of the <classname>Item</classname> class. Then for each of those item classes, I am creating
			a stub using <function>Phake::when()</function> that will return 100, 200, and 300 respectively. I know my method
			that I am getting ready to implement will need to call those methods in order to calculate the total cost of the
			order.
		</para>
		<para>
			My test is written so now it is time to see how it fails. I run it with phpunit and see the output in <xref linkend="method-stubbing.simple-stubbing.ordertest-v1-output" />
		</para>
		<xi:include href="method-stubbing/simple-stubbing/ordertest-v1-output.xml" />
		<para>
			Now that I have a working (and I by working I mean breaking!) test it is time to look at the code necessary to make
			the test pass.
		</para>
		<xi:include href="method-stubbing/simple-stubbing/order-v2.xml" />
		<para>
			The code here is pretty simple. I am just iterating over the <property>ShoppingCart::$item</property> property,
			calling the <function>Item::getPrice()</function> method, and adding them all together. Now when I run my test, I
			get <xref linkend="method-stubbing.simple-stubbing.ordertest-v2-output" />. The tests were successful and I am getting
			off to a great start with my shopping cart.
		</para>
		<xi:include href="method-stubbing/simple-stubbing/ordertest-v2-output.xml" />
		<para>
			So, what is Phake doing here? Phake is providing us a predictable implementation of the <function>Item::getPrice()</function>
			method that we can use in our test. It helps me to ensure the when my test breaks I know exactly where it is breaking.
			I will not have to be worried that a bad implementation of <function>Item::getPrice()</function> is breaking my tests.
		</para>
		<para>
			Internally Phake is doing quite a bit when this test runs. The three calls to <function>Phake::mock()</function> are
			creating three new classes that in this case each implement the <classname>Item</classname> interface. These new classes
			each define implementations of any method defined in the <classname>Item</classname> interface. If <classname>Item</classname>
			extended another interface, implementations of all of that parent's defined methods would be created as well. Each
			method being implemented in these new classes does a few different things. The first thing that it does is record
			the fact that the method was called and stores the parameters that were used to call it.
		</para>
		<para>
			The Phake::when() call here ensures that whenever the method foo() is called with no parameters on the object $mock the string ‘bar’ will be returned. If the method you are stubbing normally accepts parameters you can use any of the Method Parameter Matchers that you would also use for Phake::verify(). The various method matchers are discussed later on in Method Parameter Matchers.
		</para>
		<para>
			Whenever a mock object is created using Phake::mock() all methods by default will simply return null. The reasoning behind this is that generally speaking, each method you test should depend on only what it needs to perform the (hopefully one) responsibility assigned to it. Normally you will have very controlled delegation to other objects. To help with localization of errors in your test it is assumed that you will always want to mock external dependencies to keep them from influencing the results of unit tests dedicated to the behavior of other parts of the system. Another reason for this default behavior is that it provides consistent and predictable behavior regardless of whether you are testing concrete classes, abstract classes, or interfaces. It should be noted that this default behavior for concrete methods in classes is different then the default behavior in PHPUnit. In PHPUnit, you have to explicitly indicate that you are mocking a method, otherwise it will call the actual method code. There are certainly cases where this is useful and this behavior can be achieved in Phake. I will discuss this aspect of Phake later in this chapter.
		</para>
	</section>
	<section><title>Overwriting Existing Stubs</title>
		<para>
			Users of Phake will often setup stubs as a part of a common test fixture. (setUp() in PHPUnit.) This helps reduce duplicate code which in turn makes your tests more maintainable. However, it often happens that for all but one test, the stubbing needs to be the same, and then you have a single test that is reponsible for an error condition of some sort. Phake allows you to redefine a previously defined stub. The way that stubbing works internally in Phake is that each stub defined with Phake::when() is kept in what is essentially an array. Then, when a method call is made, this array is iterated through in reverse order and the first stub that matches the current method invocation is used to provide the answer to that call. So, by virtue of redefining a stub using the same parameters, the new stub will always be the first to match. An example of how this works is shown below.
		</para>
		<xi:include href="method-stubbing/redefine-stub.xml" />
	</section>
	<section><title>Stubbing Multiple Calls</title>
		<para>
			It is very easy to stub multiple calls to the same method in Phake. If the various calls to a method that are being stubbed utilize different parameters in each call then you can simply create multiple stubs using Phake::when(). An example of this can be seen below.
		</para>
		<xi:include href="method-stubbing/multiple-stubs.xml" />
		<para>
			In the above example, I have stubbed two variations of the add() method. The first stub will return 4 when add() is called with the parameters 2 and 2. The second stub will return 8 when add() is called with the parameters 3 and 5.
		</para>
	</section>
	<section><title>Stubbing Consecutive Calls</title>
		<para>
			Occasionally you may also want to stub multiple calls to the same method. A very common case for this is a test that involves iterators. When you step through an iterator, you normally expect multiple calls to Iterator::next() to return different elements. To achieve a different result on each call to a stub you can chain the answer portion of Phake::when() together. So your stubbing may start to look like this: Phake::when($itr)->thenReturn(1)->thenReturn(2)->thenReturn(3).
		</para>
		<para>
			Below is an example that utilizes this functionality to test a custom function named iterator_sum() which is supposed to take all of the values in an iterator and return their sum.
		</para>
		<xi:include href="method-stubbing/consecutive-calls.xml" />
	</section>
	<section><title>Answers</title>
		<para>
			In all of the examples so far, the thenReturn() answer is being used. There are other answers that are remarkably useful writing your tests.
		</para>
	</section>
	<section><title>Throwing Exceptions</title>
		<para>
			Exception handling is a common aspect of most object oriented systems that should be tested. The key to being able to test your exception handling is to be able to control the throwing of your exceptions. Phake allows this using the thenThrow() answer. This answer allows you to throw a specific exception from any mocked method. Below is an example of a piece of code that catches an exception from the method foo() and then logs a message with the exception message.
		</para>
		<xi:include href="method-stubbing/exception-logger.xml" />
		<para>
			In order to test this we must mock foo() so that it throws an exception when it is called. Then we can verify that log() is called with the appropriate message.
		</para>
		<xi:include href="method-stubbing/test-exception-logger.xml" />
	</section>
	<section><title>Calling the Parent</title>
		<para>
			Phake provides the ability to allow calling the actual method of an object on a method by method
			basis by using the thenCallParent() answer. This will result in the actual method being called.
			Consider the following class.
		</para>
		<xi:include href="method-stubbing/call-parent-class.xml" />
		<para>
			The thenCallParent() answer can be used here to ensure that the actual method in the class is 
			called resulting in the value 42 being returned from calls to that mocked method.
		</para>
		<xi:include href="method-stubbing/test-call-parent-class.xml" />
		<para>
			Please avoid using this answer as much as possible especially when testing newly written code. If you find yourself requiring a class to be only partially mocked then that is a code smell for a class that is likely doing too much. An example of when this is being done is why you are testing a class that has a singular method that has a lot of side effects that you want to mock while you allow the other methods to be called as normal. In this case that method that you are desiring to mock should belong to a completely separate class. It is obvious by the very fact that you are able to mock it without needing to mock other messages that it performs a different function.
		</para>
		<para>
			Even though partial mocking should be avoided with new code, it is often very necessary to allow creating tests while refactoring legacy code, tests involving 3rd party code that can’t be changed, or new tests of already written code that cannot yet be changed. This is precisely the reason why this answer exists and is also why it is not the default answer in Phake.
		</para>
	</section>
	<section><title>Capturing a Return Value</title>
		<para>
			Another tool in Phake for testing legacy code is the captureReturnTo() answer. This performs a function similar to argument capturing, however it instead captures what the actual method of a mock object returns to the variable passed as its parameter. Again, this should never be needed if you are testing newly written code. However I have ran across cases several times where legacy code calls protected factory methods and the result of the method call is never exposed. This answer gives you a way to access that variable to ensure that the factory was called and is operating correctly in the context of your method that is being tested.
		</para>
	</section>
	<section><title>Custom Answers</title>
		<para>
			While the answers provided in Phake should be able to cover most of the scenarios you will run into when using mocks in your unit tests there may occasionally be times when you need more control over what is returned from your mock methods. When this is the case, you can use a custom answer. All answers in Phake implement the Phake_Stubber_IAnswer interface. This interface defines a single method called getAnswer() that can be used to return what will be returned from a call to the method being stubbed. If you need to get access to how the method you are stubbing was invoked, there is a more complex set of interfaces that can be implemented: Phake_Stubber_Answers_IDelegator and Phake_Stubber_IAnswerDelegate.
		</para>
		<para>
			Phake_Stubber_Answers_IDelegator extends Phake_Stubber_IAnswer and defines an additional method called processAnswer() that is used to perform processing on the results of getAnswer() prior to passing it on to the stub’s caller. Phake_Stubber_IAnswerDelegate defines an interface that allows you to create a callback that is called to generate the answer from the stub. It defines getCallBack() which allows you to generate a PHP callback based on the object, method, and arguments that a stub was called with. It also defines getArguments() which allows you to generate the arguments that will be passed to the callback based on the method name and arguments the stub was called with.
		</para>
	</section>
	<section><title>Stubbing Reference Parameters</title>
		<para>
			Occasionally you may run into code that utilizes reference parameters to provide additional output
			from a method. This is not an uncommon thing to run into with legacy code. Phake provides a custom
			parameter matcher (these are discussed further in <xref linkend="chapter.method-parameter-matchers" />)
			that allows you to set reference parameters. It can be accessed using <function>Phake::setReference()</function>.
			The only parameter to this matcher is the value you would like to set the reference parameter 
			to provided all other parameters match. In <xref linkend="method-stubbing.set-reference-parameter" /> you can see an example of how
			<function>Phake::setReference()</function> can be used.
		</para>
		<xi:include href="method-stubbing/set-reference-parameter.xml" />
		<para>
			In <xref linkend="method-stubbing.set-reference-parameter" /> I am testing a new class I have created called <classname>ValidationLogger</classname>.
			It is a decorator for other implementations of <classname>IValidator</classname> that allows adding
			logging to any other validator. The <function>IValidator::validate()</function> method will always
			return an array of errors into the second parameter (a reference parameter) provided to the method.
			These errors are what my logger is responsible for logging. So in order for my test to work properly,
			I will need to be able to set that second parameter as a part of my stubbing call.
		</para>
		<para>
			In the call to <literal>Phake::when($validator)->validate()</literal> I have passed a call to
			<function>Phake::setReference()</function> as the second parameter. This is causing the mock
			implementation of <classname>IValidator</classname> to set <literal>$errors</literal> in
			<function>ValidationLogger::validate()</function> to the array specified by <literal>$expectedErrors</literal>.
			This allows me to quickly and easily validate that I am actually logging the errors returned back
			in the reference parameter.
		</para>
		<para>
			By default <function>Phake::setReference()</function> will always return true regardless of the 
			parameter initially passed in. If you would like to only set a reference parameter when that reference
			parameter was passed in as a certain value you can use the <function>when()</function> modifier.
			This takes a single parameter matcher as an argument. In <xref linkend="method-stubbing.set-conditional-reference-parameter" />
			you will see that the test has been modified to call <function>when()</function> on the result
			of <function>Phake::setReference()</function>. This modification will cause the reference parameter
			to be set only if the <literal>$errors</literal> parameter passed to <function>IValidatore::validate()</function>
			is initially passed as an empty array.
		</para>
		<xi:include href="method-stubbing/set-conditional-reference-parameter.xml" />
		<para>
			Please note, when you are using <function>Phake::setReference()</function> you still must provide
			an answer for the stub. If you use this function and your reference parameter is never changed,
			that is generally the most common reason.
		</para>
	</section>
	<section><title>Partial Mocks</title>
		<para>
			When testing legacy code, if you find that the majority of the methods in the mock are using the thenCallParent() answer, you may find it easier to just use a partial mock in Phake. Phake partial mocks also allow you to call the actual constructor of the class being mocked. They are created using Phake::partialMock(). Like Phake::mock(), the first parameter is the name of the class that you are mocking. However, you can pass additional parameters that will then be passed as the respective parameters to that class’ constructor. The other notable feature of a partial mock in Phake is that its default answer is to pass the call through to the parent as if you were using thenCallParent().
		</para>
		<para>
			Consider the following class that has a method that simply returns the value passed into the constructor.
		</para>
		<xi:include href="method-stubbing/partial-mock.xml" />
		<para>
			Using Phake::partMock() you can instantiate a mock object that will allow this object to function
			as designed while still allowing verification as well as selective stubbing of certain calls.
			Below is an example that shows the usage of Phake::partMock()
		</para>
		<xi:include href="method-stubbing/test-partial-mock.xml" />
		<para>
			Again, partial mocks should not be used when you are testing new code. If you find yourself using them be sure to inspect your design to make sure that the class you are creating a partial mock is not doing too much.
		</para>
	</section>
	<section><title>Setting Default Stubs</title>
		<para>
			You can also change the default stubbing for mocks created with Phake::mock(). This is done by using the second parameter to Phake::mock() in conjunction with the Phake::ifUnstubbed() method. The second parameter to Phake::mock() is reserved for configuring the behavior of an individual mock. Phake::ifUnstubbed() allows you to specify any of the matchers mentioned above as the default answer if any method invocation is not explicitly stubbed. If this configuration directive is not provided then the method will return NULL by default. An example of this can be seen below.
		</para>
		<xi:include href="method-stubbing/default-stubs.xml" />
	</section>
	<section><title>Stubbing Magic Methods</title>
		<para>
			The verification of __call() was discussed in the previous chapter. Magic methods can also be stubbed in much the same way. If you want to verify a particular invocation of __call() you can stub the actual method call by mocking the method passed in as the first parameter.
		</para>
		<para>
			Consider the following class.
		</para>
		<xi:include href="method-stubbing/magic-class.xml" />
		<para>
			You could stub an invocation of the __call() method through a userspace call to magicCall() with the following code.
		</para>
		<xi:include href="method-stubbing/magic-method-stub.xml" />
		<para>
			If for any reason you need to explicitly stub calls to __call() then you can use Phake::whenCallMethodWith().
		</para>
		<xi:include href="method-stubbing/magic-method-explicit-stub.xml" />
	</section>
</chapter>
