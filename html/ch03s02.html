<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Overwriting Existing Stubs</title><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/><link rel="home" href="index.html" title="Phake - PHP Mocking Framework"/><link rel="up" href="ch03.html" title="Chapter 3. Method Stubbing"/><link rel="prev" href="ch03.html" title="Chapter 3. Method Stubbing"/><link rel="next" href="ch03s03.html" title="Stubbing Multiple Calls"/></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Overwriting Existing Stubs</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch03.html">Prev</a> </td><th width="60%" align="center">Chapter 3. Method Stubbing</th><td width="20%" align="right"> <a accesskey="n" href="ch03s03.html">Next</a></td></tr></table><hr/></div><div class="section" title="Overwriting Existing Stubs"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a xmlns:saxon="http://icl.com/saxon" id="d4e118"/>Overwriting Existing Stubs</h2></div></div></div>
		<p>
			Users of Phake will often setup stubs as a part of a common test fixture. (setUp() in PHPUnit.) This helps reduce duplicate code which in turn makes your tests more maintainable. However, it often happens that for all but one test, the stubbing needs to be the same, and then you have a single test that is reponsible for an error condition of some sort. Phake allows you to redefine a previously defined stub. The way that stubbing works internally in Phake is that each stub defined with Phake::when() is kept in what is essentially an array. Then, when a method call is made, this array is iterated through in reverse order and the first stub that matches the current method invocation is used to provide the answer to that call. So, by virtue of redefining a stub using the same parameters, the new stub will always be the first to match. An example of how this works is shown below.
		</p>
		<div class="example"><a xmlns:saxon="http://icl.com/saxon" id="method-stubbing.redefine-stub"/><p class="title"><b>Example 3.2. Redefining Stubs</b></p><div class="example-contents">
	
		<pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?php</span>
<b class="hl-keyword">class</b> PhakeTest <b class="hl-keyword">extends</b> PHPUnit_Framework_TestCase
{
	<b class="hl-keyword">public</b> <b class="hl-keyword">function</b> testRedefineStub()
	{
		$mock = Phake::mock(<b class="hl-string"><i style="color:red">'PhakeTest_MockedClass'</i></b>);

		Phake::when($mock)-&gt;foo()-&gt;thenReturn(<span class="hl-number">24</span>);
		Phake::when($mock)-&gt;foo()-&gt;thenReturn(<span class="hl-number">42</span>);

		$this-&gt;assertEquals(<span class="hl-number">42</span>, $mock-&gt;foo());
	}
}
<span class="hl-directive" style="color: maroon">?&gt;</span></pre>
</div></div><br class="example-break"/>
	</div><div class="navfooter"><hr/><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch03.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ch03.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ch03s03.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 3. Method Stubbing </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Stubbing Multiple Calls</td></tr></table></div></body></html>