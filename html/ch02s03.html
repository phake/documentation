<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Verifying Multiple Invocations</title><meta name="generator" content="DocBook XSL Stylesheets V1.75.2" /><link rel="home" href="index.html" title="Phake - PHP Mocking Framework" /><link rel="up" href="ch02.html" title="Chapter 2. Method Verification" /><link rel="prev" href="ch02s02.html" title="Verifying Method Parameters" /><link rel="next" href="ch02s04.html" title="Verifying Calls Happen in a Particular Order" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Verifying Multiple Invocations</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch02s02.html">Prev</a> </td><th width="60%" align="center">Chapter 2. Method Verification</th><td width="20%" align="right"> <a accesskey="n" href="ch02s04.html">Next</a></td></tr></table><hr /></div><div class="section" title="Verifying Multiple Invocations"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id1183085"></a>Verifying Multiple Invocations</h2></div></div></div>
		<p>
			A common need for mock objects is the ability to variable multiple invocations on that object. Phake allows you to use Phake::verify() multiple times on the same object. A notable difference between Phake and PHPUnit’s mocking framework is the ability to mock multiple invocations of the same method with no regard for call sequences. The PHPUnit mocking test below would fail for this reason.
		</p>
		<div class="example"><a id="Introduction.examples.CardGame.php"></a><p class="title"><b>Example 2.2. CardGame class</b></p><div class="example-contents">
	
		<pre class="programlisting">&lt;?php

class CardGame
{
	private $dealerStrategy;
	private $deck;
	private $players;

	public function CardGame(DealerStrategy $dealerStrategy, CardCollection $deck, PlayerCollection $players)
	{
		$this-&gt;dealerStrategy = $dealerStrategy;
		$this-&gt;deck = $deck;
		$this-&gt;players = $players;
	}

	public function dealCards()
	{
		$this-&gt;deck-&gt;shuffle();
		$this-&gt;dealerStrategy-&gt;deal($deck, $players);
	}
}

?&gt;</pre>
</div></div><br class="example-break" />
		<p>
			The reason this test fails is because by default PHPUnit only allows a singl expectation per method. The way you can fix this is by using the at() matcher. This allows you to specify the index of the invocation you want to match again. So to make the test above work you would have to change it.
		</p>
		<div class="example"><a id="Introduction.examples.CardGame.php"></a><p class="title"><b>Example 2.3. CardGame class</b></p><div class="example-contents">
	
		<pre class="programlisting">&lt;?php

class CardGame
{
	private $dealerStrategy;
	private $deck;
	private $players;

	public function CardGame(DealerStrategy $dealerStrategy, CardCollection $deck, PlayerCollection $players)
	{
		$this-&gt;dealerStrategy = $dealerStrategy;
		$this-&gt;deck = $deck;
		$this-&gt;players = $players;
	}

	public function dealCards()
	{
		$this-&gt;deck-&gt;shuffle();
		$this-&gt;dealerStrategy-&gt;deal($deck, $players);
	}
}

?&gt;</pre>
</div></div><br class="example-break" />
		<p>
			This test will now run as expected. There is still one small problem however and that is that you are now testing not just the invocations but also the order of invocations. Many times the order in which two calls are made really do not matter. If swapping the order of two method calls will not break your application then there is no reason to enforce that code structure through a unit test. Unfortunately, you cannot have multiple invocations of a method in PHPUnit without enforcing call order. In Phake these two notions of call order and multiple invocations are kept completely distinct. Here is the same test written using Phake.
		</p>
		<div class="example"><a id="Introduction.examples.CardGame.php"></a><p class="title"><b>Example 2.4. CardGame class</b></p><div class="example-contents">
	
		<pre class="programlisting">&lt;?php

class CardGame
{
	private $dealerStrategy;
	private $deck;
	private $players;

	public function CardGame(DealerStrategy $dealerStrategy, CardCollection $deck, PlayerCollection $players)
	{
		$this-&gt;dealerStrategy = $dealerStrategy;
		$this-&gt;deck = $deck;
		$this-&gt;players = $players;
	}

	public function dealCards()
	{
		$this-&gt;deck-&gt;shuffle();
		$this-&gt;dealerStrategy-&gt;deal($deck, $players);
	}
}

?&gt;</pre>
</div></div><br class="example-break" />
		<p>
			You can switch the calls around in this example as much as you like and the test will still pass. You can mock as many different invocations of the same method as you need.
		</p>
		<p>
			If you would like to verify the exact same parameters are used on a method multiple times (or they all match the same constraints multiple times) then you can use the verification mode parameter of Phake::verify(). The second parameter to Phake::verify() allows you to specify how many times you expect that method to be called with matching parameters. If no value is specified then the default of one is used. The other options are:
		</p>
		<div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">Phake::times($n) – Where $n equals the exact number of times you expect the method to be called.</li><li class="listitem">Phake::atLeast($n) – Where $n is the minimum number of times you expect the method to be called.</li><li class="listitem">Phake::atMost($n) – Where $n is the most number of times you would expect the method to be called.</li></ol></div>
		<p>
			Here is an example of this in action.
		</p>
		<div class="example"><a id="Introduction.examples.CardGame.php"></a><p class="title"><b>Example 2.5. CardGame class</b></p><div class="example-contents">
	
		<pre class="programlisting">&lt;?php

class CardGame
{
	private $dealerStrategy;
	private $deck;
	private $players;

	public function CardGame(DealerStrategy $dealerStrategy, CardCollection $deck, PlayerCollection $players)
	{
		$this-&gt;dealerStrategy = $dealerStrategy;
		$this-&gt;deck = $deck;
		$this-&gt;players = $players;
	}

	public function dealCards()
	{
		$this-&gt;deck-&gt;shuffle();
		$this-&gt;dealerStrategy-&gt;deal($deck, $players);
	}
}

?&gt;</pre>
</div></div><br class="example-break" />
	</div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch02s02.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ch02.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ch02s04.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Verifying Method Parameters </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Verifying Calls Happen in a Particular Order</td></tr></table></div></body></html>
