<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Parameter Capturing</title><meta name="generator" content="DocBook XSL Stylesheets V1.75.2" /><link rel="home" href="index.html" title="Phake - PHP Mocking Framework" /><link rel="up" href="ch04.html" title="Chapter 4. Method Parameter Matchers" /><link rel="prev" href="ch04s02.html" title="Using Hamcrest Matchers" /><link rel="next" href="ch04s04.html" title="Custom Parameter Matchers" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Parameter Capturing</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch04s02.html">Prev</a> </td><th width="60%" align="center">Chapter 4. Method Parameter Matchers</th><td width="20%" align="right"> <a accesskey="n" href="ch04s04.html">Next</a></td></tr></table><hr /></div><div class="section" title="Parameter Capturing"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id1407223"></a>Parameter Capturing</h2></div></div></div>
		<p>
			As you can see there are a variety of methods for verifying that the appropriate parameters are being passed to methods. However, there may be times when the prebuilt constraints and matchers simply do not fit your needs. Perhaps there is method that accepts a complex object where only certain components of the object need to be validated. Parameter capturing will allow you to store the parameter that was used to call your method so that it can be used in assertions later on.
		</p>
		<p>
			Consider the following example where I have defined a getNumberOfCards() method on the CardCollection interface.
		</p>
		<div class="example"><a id="Introduction.examples.CardGame.php"></a><p class="title"><b>Example 4.6. CardGame class</b></p><div class="example-contents">
	
		<pre class="programlisting">&lt;?php

class CardGame
{
	private $dealerStrategy;
	private $deck;
	private $players;

	public function CardGame(DealerStrategy $dealerStrategy, CardCollection $deck, PlayerCollection $players)
	{
		$this-&gt;dealerStrategy = $dealerStrategy;
		$this-&gt;deck = $deck;
		$this-&gt;players = $players;
	}

	public function dealCards()
	{
		$this-&gt;deck-&gt;shuffle();
		$this-&gt;dealerStrategy-&gt;deal($deck, $players);
	}
}

?&gt;</pre>
</div></div><br class="example-break" />
		<p>
			I want to create new functionality for a my poker dealer strategy that will check to make sure we are playing with a full deck of 52 cards when the deal() call is made. It would be rather cumbersome to create a copy of a CardCollection implementation that I could be sure would match in an equals scenario. Such a test would look something like this.
		</p>
		<p>
			Please note, I do not generally advocate this type of design. I prefer a dependency injection versus instantiation. So please remember, this is not an example of clean design, simply an example of what you can do with argument capturing.
		</p>
		<div class="example"><a id="Introduction.examples.CardGame.php"></a><p class="title"><b>Example 4.7. CardGame class</b></p><div class="example-contents">
	
		<pre class="programlisting">&lt;?php

class CardGame
{
	private $dealerStrategy;
	private $deck;
	private $players;

	public function CardGame(DealerStrategy $dealerStrategy, CardCollection $deck, PlayerCollection $players)
	{
		$this-&gt;dealerStrategy = $dealerStrategy;
		$this-&gt;deck = $deck;
		$this-&gt;players = $players;
	}

	public function dealCards()
	{
		$this-&gt;deck-&gt;shuffle();
		$this-&gt;dealerStrategy-&gt;deal($deck, $players);
	}
}

?&gt;</pre>
</div></div><br class="example-break" />
		<p>
			You can also capture parameters if they meet a certain condition. For instance, if someone mistakenly passed an array as the first parameter to the deal() method then PHPUnit would fatal error out. This can be protected against by using the the Phake::capture()-&gt;when() method. The when() method accepts the same constraints that Phake::verify() accepts. Here is how you could leverage that functionality to bulletproof your captures a little bit.
		</p>
		<div class="example"><a id="Introduction.examples.CardGame.php"></a><p class="title"><b>Example 4.8. CardGame class</b></p><div class="example-contents">
	
		<pre class="programlisting">&lt;?php

class CardGame
{
	private $dealerStrategy;
	private $deck;
	private $players;

	public function CardGame(DealerStrategy $dealerStrategy, CardCollection $deck, PlayerCollection $players)
	{
		$this-&gt;dealerStrategy = $dealerStrategy;
		$this-&gt;deck = $deck;
		$this-&gt;players = $players;
	}

	public function dealCards()
	{
		$this-&gt;deck-&gt;shuffle();
		$this-&gt;dealerStrategy-&gt;deal($deck, $players);
	}
}

?&gt;</pre>
</div></div><br class="example-break" />
		<p>
			This could also be done by using PHPUnit's assertions later on with the captured parameter, however this also has a side effect of better localizing your error. Here is the error you would see if the above test failed.
		</p>
		<div class="example"><a id="Introduction.examples.CardGame.php"></a><p class="title"><b>Example 4.9. CardGame class</b></p><div class="example-contents">
	
		<pre class="programlisting">&lt;?php

class CardGame
{
	private $dealerStrategy;
	private $deck;
	private $players;

	public function CardGame(DealerStrategy $dealerStrategy, CardCollection $deck, PlayerCollection $players)
	{
		$this-&gt;dealerStrategy = $dealerStrategy;
		$this-&gt;deck = $deck;
		$this-&gt;players = $players;
	}

	public function dealCards()
	{
		$this-&gt;deck-&gt;shuffle();
		$this-&gt;dealerStrategy-&gt;deal($deck, $players);
	}
}

?&gt;</pre>
</div></div><br class="example-break" />
		<p>
			It should be noted that while it is possible to use argument capturing for stubbing with Phake::when() I would discourage it. When stubbing a method you should only be concerned about making sure an expected value is return and argument capturing in no way helps with that goal. In the worst case scenario you will have some incredibly difficult test failures to diagnose.
		</p>
	</div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch04s02.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ch04.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ch04s04.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Using Hamcrest Matchers </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Custom Parameter Matchers</td></tr></table></div></body></html>
