<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Method Stubbing &#8212; Phake - PHP Mocking Framework 4.0.0 documentation</title>
    
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '4.0.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="top" title="Phake - PHP Mocking Framework 4.0.0 documentation" href="index.html" />
    <link rel="next" title="Method Verification" href="method-verification.html" />
    <link rel="prev" title="Creating Mocks" href="mocks.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="method-verification.html" title="Method Verification"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="mocks.html" title="Creating Mocks"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Phake - PHP Mocking Framework 4.0.0 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="method-stubbing">
<span id="method-stubbing-section"></span><h1>Method Stubbing<a class="headerlink" href="#method-stubbing" title="Permalink to this headline">Â¶</a></h1>
<p>The <code class="docutils literal"><span class="pre">Phake::when()</span></code> method is used to stub methods in Phake. As discussed in the introduction,
stubbing allows an object method to be forced to return a particular value given a set of parameters. Similarly to
<code class="docutils literal"><span class="pre">Phake::verify()</span></code>, <code class="docutils literal"><span class="pre">Phake::when()</span></code> accepts a mock object generated from
<code class="docutils literal"><span class="pre">Phake::mock()</span></code> as its first parameter.</p>
<p>Imagine I was in the process of building the next great online shopping cart. The first thing any
good shopping cart allows is to be able to add items. The most important thing I want to know from
the shopping cart is how much money in merchandise is in there. So, I need to make myself a
ShoppingCart class. I also am going to need some class to define my items.
I am more worried about the money right now and because of that I am keenly aware that any item
in a shopping cart is going to have a price. So I will just create an interface to represent those
items called Item. Now take a minute to marvel at the creativity of those
names. Great, now check out the initial definitions for my objects.</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="x">/**</span>
<span class="x"> * An item that is going to make me rich.</span>
<span class="x"> */</span>
<span class="x">interface Item</span>
<span class="x">{</span>
<span class="x">    public function getPrice()</span>
<span class="x">}</span>

<span class="x">/**</span>
<span class="x"> * A customer&#39;s cart that will contain items that are going to make me rich.</span>
<span class="x"> */</span>
<span class="x">class ShoppingCart</span>
<span class="x">{</span>
<span class="x">    private array $items = [];</span>

<span class="x">    /**</span>
<span class="x">     * Adds an item to the customer&#39;s order</span>
<span class="x">     */</span>
<span class="x">    public function addItem(Item $item): void</span>
<span class="x">    {</span>
<span class="x">        $this-&gt;items[] = $item;</span>
<span class="x">    }</span>

<span class="x">    /**</span>
<span class="x">     * Returns the current sub total of the customer&#39;s order</span>
<span class="x">     */</span>
<span class="x">    public function getSubTotal()</span>
<span class="x">    {</span>
<span class="x">    }</span>
<span class="x">}</span>
</pre></div>
</div>
<p>So, I am furiously coding away at this fantastic new <code class="docutils literal"><span class="pre">ShoppingCart</span></code> class when I
realize, I am doing it wrong! You see, a few years ago I went to this conference with a bunch of
other geeky people to talk about how to make quality software. I am supposed to be writing unit
tests. Here I am, a solid thirteen lines (not counting comments) of code into my awe inspiring
new software and I haven&#8217;t written a single test. I tell myself, &#8220;There&#8217;s no better time to change
than right now!&#8221; So I decide to start testing. After looking at the options I decide PHPUnit with
this sweet new mock library called Phake is the way to go.</p>
<p>My first test is going to be for the currently unimplemented <code class="docutils literal"><span class="pre">ShoppingCart::getSubTotal()</span></code>
method. I already have a pretty good idea of what this function is going to need to do. It will
need to look at all of the items in the cart, retrieve their price, add it all together and return
the result. So, in my test I know I am going to need a fixture that sets up a shopping cart with
a few items added. Then I am going to need a test that calls <code class="docutils literal"><span class="pre">ShoppingCart::getSubTotal()</span></code>
and asserts that it returns a value equal to the price of the items I added to the cart. One catch
though, I don&#8217;t have any concrete instances of an <code class="docutils literal"><span class="pre">Item</span></code>. I wasn&#8217;t even planning on doing any of
that until tomorrow. I really want to just focus on the <code class="docutils literal"><span class="pre">ShoppingCart</span></code> class.
Never fear, this is why I decided to use Phake. I remember reading about how it will allow me to
quickly create instance of my classes and interfaces that I can set up stubs for so that method
calls return predictable values. This project is all coming together and I am really excited.</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="x">class ShoppingCartTest extends PHPUnit\Framework\TestCase</span>
<span class="x">{</span>
<span class="x">    public function testGetSub()</span>
<span class="x">    {</span>
<span class="x">        $item1 = Phake::mock(Item::class);</span>
<span class="x">        $item2 = Phake::mock(Item::class);</span>
<span class="x">        $item3 = Phake::mock(Item::class);</span>

<span class="x">        Phake::when($item1)-&gt;getPrice()-&gt;thenReturn(100);</span>
<span class="x">        Phake::when($item2)-&gt;getPrice()-&gt;thenReturn(200);</span>
<span class="x">        Phake::when($item3)-&gt;getPrice()-&gt;thenReturn(300);</span>

<span class="x">        $shoppingCart = new ShoppingCart();</span>
<span class="x">        $shoppingCart-&gt;addItem($item1);</span>
<span class="x">        $shoppingCart-&gt;addItem($item2);</span>
<span class="x">        $shoppingCart-&gt;addItem($item3);</span>

<span class="x">        $this-&gt;assertEquals(600, $shoppingCart-&gt;getSubTotal());</span>
<span class="x">    }</span>
<span class="x">}</span>
</pre></div>
</div>
<p>My test here shows a very basic use of Phake for creating method stubs. I am creating three different mock
implementations of the <code class="docutils literal"><span class="pre">Item</span></code> class. Then for each of those item classes, I am creating
a stub using <code class="docutils literal"><span class="pre">Phake::when()</span></code> that will return 100, 200, and 300 respectively. I know my method
that I am getting ready to implement will need to call those methods in order to calculate the total cost of the
order.</p>
<p>My test is written so now it is time to see how it fails. I run it with phpunit and see the output below:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>$ phpunit ExampleTests/ShoppingCartTest.php
PHPUnit 9.5.4 by Sebastian Bergmann and contributors.

F                                                                   1 / 1 (100%)

Time: 00:00.012, Memory: 4.00 MB

There was 1 failure:

1) ShoppingCartTest::testGetSub
Failed asserting that null matches expected 600.

/home/mikel/Documents/Projects/Phake/tests/ShoppingCartTest.php:69

FAILURES!
Tests: 1, Assertions: 1, Failures: 1.
</pre></div>
</div>
<p>Now that I have a working (and I by working I mean breaking!) test it is time to look at the code necessary to make
the test pass.</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="x">class ShoppingCart</span>
<span class="x">{</span>
<span class="x">    // I am cutting out the already seen code. If you want to see it again look at the previous examples!</span>

<span class="x">    /**</span>
<span class="x">     * Returns the current sub total of the customer&#39;s order</span>
<span class="x">     */</span>
<span class="x">    public function getSubTotal()</span>
<span class="x">    {</span>
<span class="x">        $total = 0;</span>

<span class="x">        foreach ($this-&gt;items as $item)</span>
<span class="x">        {</span>
<span class="x">            $total += $item-&gt;getPrice();</span>
<span class="x">        }</span>

<span class="x">        return $total;</span>
<span class="x">    }</span>
<span class="x">}</span>
</pre></div>
</div>
<p>The code here is pretty simple. I am just iterating over the <code class="docutils literal"><span class="pre">ShoppingCart::$item</span></code> property,
calling the <code class="docutils literal"><span class="pre">Item::getPrice()</span></code> method, and adding them all together. Now when I run phpunit, the tests were successful
and I am getting off to a great start with my shopping cart.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>$ phpunit ExampleTests/ShoppingCartTest.php
PHPUnit 9.5.4 by Sebastian Bergmann and contributors.

.                                                                   1 / 1 (100%)

Time: 00:00.011, Memory: 4.00 MB

OK (1 test, 1 assertion)
</pre></div>
</div>
<p>So, what is Phake doing here? Phake is providing us a predictable implementation of the <code class="docutils literal"><span class="pre">Item::getPrice()</span></code>
method that we can use in our test. It helps me to ensure the when my test breaks I know exactly where it is breaking.
I will not have to be worried that a bad implementation of <code class="docutils literal"><span class="pre">Item::getPrice()</span></code> is breaking my tests.</p>
<div class="section" id="how-phake-when-works">
<span id="id1"></span><h2>How Phake::when() Works<a class="headerlink" href="#how-phake-when-works" title="Permalink to this headline">Â¶</a></h2>
<p>Internally Phake is doing quite a bit when this test runs. The three calls to <code class="docutils literal"><span class="pre">Phake::mock()</span></code> are
creating three new classes that in this case each implement the <code class="docutils literal"><span class="pre">Item</span></code> interface. These new classes
each define implementations of any method defined in the <code class="docutils literal"><span class="pre">Item</span></code> interface. If <code class="docutils literal"><span class="pre">Item</span></code>
extended another interface, implementations of all of that parent&#8217;s defined methods would be created as well. Each
method being implemented in these new classes does a few different things. The first thing that it does is record
the fact that the method was called and stores the parameters that were used to call it. The next significant thing
it does is looks at the stub map for that mock object. The stub map is a map that associates answers to method matchers.
An answer is what a mocked object will return when it is called. By default, a call to a mock object returns a static
answer of NULL. We will discuss answers more in <a class="reference internal" href="answers.html#answers"><span class="std std-ref">Answers</span></a>. A method matcher has two parts. The
first is the method name. The second is an array of arguments. The array of arguments will then contain various constraints
that are applied to each argument to see if a given argument will match. The most common constraint is an equality constraint
that will match loosely along the same lines as the double equals sign in PHP. We will talk about matchers more in
<a class="reference internal" href="method-parameter-matchers.html#method-parameter-matchers-section"><span class="std std-ref">Method Parameter Matchers</span></a>.</p>
<p>When each mock object is initially created, its stub map will be empty. This means that any call to a method on a mock object
is going to return a default answer of NULL. If you want your mock object&#8217;s methods to return something else you must add answers
to the stub map. The <code class="docutils literal"><span class="pre">Phake::when()</span></code> method allows you to map an answer to a method matcher for a given mock object.
The mock object you want to add the mapping to is passed as the first parameter to <code class="docutils literal"><span class="pre">Phake::when()</span></code>. The
<code class="docutils literal"><span class="pre">Phake::when()</span></code> method will then return a proxy that can be used add answers to your mock object&#8217;s stub
map. The answers are added by making method calls on the proxy just as you would on the mock object you are proxying. In
the first example above you saw a call to <code class="docutils literal"><span class="pre">Phake::when($this-&gt;item1)-&gt;getPrice()</span></code>.
The <code class="docutils literal"><span class="pre">getPrice()</span></code> call here was telling Phake that I am about to define a new answer that will be returned
any time <code class="docutils literal"><span class="pre">$this-&gt;item-&gt;getPrice()</span></code> is called in my code. The call to <code class="docutils literal"><span class="pre">$this-&gt;item-&gt;getPrice()</span></code>
returns another object that you can set the answer on using Phake&#8217;s fluent api. In the example I called
<code class="docutils literal"><span class="pre">Phake::when($this-&gt;item1)-&gt;getPrice()-&gt;thenReturn(100)</span></code>. The <code class="docutils literal"><span class="pre">thenReturn()</span></code> method will
bind a static answer to a matcher for <code class="docutils literal"><span class="pre">getPrice()</span></code> in the stub map for $this-&gt;item1.</p>
</div>
<div class="section" id="overwriting-existing-stubs">
<h2>Overwriting Existing Stubs<a class="headerlink" href="#overwriting-existing-stubs" title="Permalink to this headline">Â¶</a></h2>
<p>My shopping cart application is coming right along. I can add items and the total price seems to be accurate. However,
while I was playing around with my new cart I noticed a very strange problem. I was playing around with the idea of
allowing discounts to be applied to a cart as just additional items that would have a negative price. So while I am
playing around with this idea I notice that the math isn&#8217;t always adding up. If I start with an item that is $100 and
then add a discount that is $81.40 I see that the total price isn&#8217;t adding up to $18.60. This is definitely problematic
After doing some further research, I realize I made a silly mistake. I am just using simple floats to calculate the
costs. Floats are by nature inaccurate. Once you start using them in mathematical operations they start to show their
inadequacy for precision. In keeping with the test driven method of creating code I need to create a unit test this flaw.</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="x">class ShoppingCartTest extends PHPUnit\Framework\TestCase</span>
<span class="x">{</span>
<span class="x">      public function testGetSub()</span>
<span class="x">      {</span>
<span class="x">          $item1 = Phake::mock(Item::class);</span>
<span class="x">          $item2 = Phake::mock(Item::class);</span>
<span class="x">          $item3 = Phake::mock(Item::class);</span>

<span class="x">          Phake::when($item1)-&gt;getPrice()-&gt;thenReturn(100);</span>
<span class="x">          Phake::when($item2)-&gt;getPrice()-&gt;thenReturn(200);</span>
<span class="x">          Phake::when($item3)-&gt;getPrice()-&gt;thenReturn(300);</span>

<span class="x">          $shoppingCart = new ShoppingCart();</span>
<span class="x">          $shoppingCart-&gt;addItem($item1);</span>
<span class="x">          $shoppingCart-&gt;addItem($item2);</span>
<span class="x">          $shoppingCart-&gt;addItem($item3);</span>

<span class="x">          $this-&gt;assertEquals(600, $shoppingCart-&gt;getSubTotal());</span>
<span class="x">      }</span>

<span class="x">      public function testGetSubTotalWithPrecision()</span>
<span class="x">      {</span>
<span class="x">          $item1 = Phake::mock(Item::class);</span>
<span class="x">          $item2 = Phake::mock(Item::class);</span>
<span class="x">          $item3 = Phake::mock(Item::class);</span>

<span class="x">          Phake::when($item1)-&gt;getPrice()-&gt;thenReturn(100);</span>
<span class="x">          Phake::when($item2)-&gt;getPrice()-&gt;thenReturn(-81.4);</span>
<span class="x">          Phake::when($item3)-&gt;getPrice()-&gt;thenReturn(20);</span>

<span class="x">          $shoppingCart = new ShoppingCart();</span>
<span class="x">          $shoppingCart-&gt;addItem($item1);</span>
<span class="x">          $shoppingCart-&gt;addItem($item2);</span>
<span class="x">          $shoppingCart-&gt;addItem($item3);</span>

<span class="x">          $this-&gt;assertEquals(38.6, $shoppingCart-&gt;getSubTotal());</span>
<span class="x">      }</span>
<span class="x">}</span>
</pre></div>
</div>
<p>You can see that I added another test method that uses actual floats for some of the prices as opposed to round numbers.
Now when I run my test suite I can see the result.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>$ phpunit ExampleTests/ShoppingCartTest.php
PHPUnit 9.5.4 by Sebastian Bergmann and contributors.

..                                                                  2 / 2 (100%)

Time: 00:00.012, Memory: 4.00 MB

OK (2 tests, 2 assertions)
</pre></div>
</div>
<p>Once you confirmed that your implementation works, I want to discuss streamlining test cases with you. You
will notice that the code in <code class="docutils literal"><span class="pre">ShoppingCartTest::testGetSubTotalWithPrecision()</span></code> contains almost
all duplicate code when compared to <code class="docutils literal"><span class="pre">ShoppingCartTest::testGetSub()</span></code>. If I were to continue following
this pattern of doing things I would eventually have tests that are difficult to maintain. Phake allows you to very
easily override stubs. This is very important in helping you to reduce duplication in your tests and leads to tests
that will be easier to maintain. To overwrite a previous stub you simply have to redefine it. I am going to change
<code class="docutils literal"><span class="pre">ShoppingCartTest::testGetSubTotalWithPrecision()</span></code> to instead just redefine the <code class="docutils literal"><span class="pre">getPrice()</span></code>
stubs.</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="x">class ShoppingCartTest extends PHPUnit\Framework\TestCase</span>
<span class="x">{</span>
<span class="x">    private ShoppingCart $shoppingCart;</span>
<span class="x">    private Item $item1;</span>
<span class="x">    private Item $item2;</span>
<span class="x">    private Item $item3;</span>

<span class="x">    public function setUp(): void</span>
<span class="x">    {</span>
<span class="x">        $this-&gt;item1 = Phake::mock(Item::class);</span>
<span class="x">        $this-&gt;item2 = Phake::mock(Item::class);</span>
<span class="x">        $this-&gt;item3 = Phake::mock(Item::class);</span>

<span class="x">        Phake::when($this-&gt;item1)-&gt;getPrice()-&gt;thenReturn(100);</span>
<span class="x">        Phake::when($this-&gt;item2)-&gt;getPrice()-&gt;thenReturn(200);</span>
<span class="x">        Phake::when($this-&gt;item3)-&gt;getPrice()-&gt;thenReturn(300);</span>

<span class="x">        $this-&gt;shoppingCart = new ShoppingCart();</span>
<span class="x">        $this-&gt;shoppingCart-&gt;addItem($this-&gt;item1);</span>
<span class="x">        $this-&gt;shoppingCart-&gt;addItem($this-&gt;item2);</span>
<span class="x">        $this-&gt;shoppingCart-&gt;addItem($this-&gt;item3);</span>
<span class="x">    }</span>

<span class="x">    public function testGetSub()</span>
<span class="x">    {</span>
<span class="x">        $this-&gt;assertEquals(600, $this-&gt;shoppingCart-&gt;getSubTotal());</span>
<span class="x">    }</span>

<span class="x">    public function testGetSubTotalWithPrecision()</span>
<span class="x">    {</span>
<span class="x">        Phake::when($this-&gt;item1)-&gt;getPrice()-&gt;thenReturn(100);</span>
<span class="x">        Phake::when($this-&gt;item2)-&gt;getPrice()-&gt;thenReturn(-81.4);</span>
<span class="x">        Phake::when($this-&gt;item3)-&gt;getPrice()-&gt;thenReturn(20);</span>

<span class="x">        $this-&gt;assertEquals(38.6, $this-&gt;shoppingCart-&gt;getSubTotal());</span>
<span class="x">    }</span>
<span class="x">}</span>
</pre></div>
</div>
<p>If you rerun this test you will get the same results shown in before.
The test itself is much simpler though there is much less unnecessary duplication. The reason this works is because
the stub map I was referring to in <a class="reference internal" href="#how-phake-when-works"><span class="std std-ref">How Phake::when() Works</span></a> isn&#8217;t really a map at all. It is more of
a stack in reality. When a new matcher and answer pair is added to a mock object, it is added to the top of the stack.
Then whenever a stub method is called, the stack is checked from the top down to find the first matcher that matches
the method that was called. So, when I created the additional stubs for the various <code class="docutils literal"><span class="pre">Item::getPrice()</span></code>
calls, I was just adding additional matchers to the top of the stack that would always get matched first by virtue
of the parameters all being the same.</p>
</div>
<div class="section" id="resetting-a-mock-s-stubs">
<h2>Resetting A Mock&#8217;s Stubs<a class="headerlink" href="#resetting-a-mock-s-stubs" title="Permalink to this headline">Â¶</a></h2>
<p>If overriding a stub does not work for your particular case and you would rather start over with all default stubs then
you can use <code class="docutils literal"><span class="pre">Phake::reset()</span></code> and <code class="docutils literal"><span class="pre">Phake::resetStatic()</span></code>. These will remove all stubs from a mock and also empty
out all recorded calls against a mock. <code class="docutils literal"><span class="pre">Phake::reset()</span></code> will do this for instance methods on the mock and
<code class="docutils literal"><span class="pre">Phake::resetStatic()</span></code> will do this for all static methods on the mock.</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="x">public function testResettingStubMapper()</span>
<span class="x">{</span>
<span class="x">    $mock = Phake::mock(PhakeTest_MockedClass::class);</span>
<span class="x">    Phake::when($mock)-&gt;foo()-&gt;thenReturn(42);</span>

<span class="x">    $this-&gt;assertEquals(42, $mock-&gt;foo());</span>

<span class="x">    Phake::reset($mock);</span>
<span class="x">    //$mock-&gt;foo() now returns the default stub which in this case is null</span>
<span class="x">    $this-&gt;assertNull($mock-&gt;foo());</span>
<span class="x">}</span>

<span class="x">public function testResettingCallRecorder()</span>
<span class="x">{</span>
<span class="x">    $mock = Phake::mock(PhakeTest_MockedClass::class);</span>
<span class="x">    $mock-&gt;foo();</span>

<span class="x">    //Will work as normal</span>
<span class="x">    Phake::verify($mock)-&gt;foo();</span>

<span class="x">    Phake::reset($mock);</span>

<span class="x">    //Will now throw an error that foo was not called</span>
<span class="x">    Phake::verify($mock)-&gt;foo();</span>
<span class="x">}</span>
</pre></div>
</div>
</div>
<div class="section" id="stubbing-multiple-calls">
<span id="id2"></span><h2>Stubbing Multiple Calls<a class="headerlink" href="#stubbing-multiple-calls" title="Permalink to this headline">Â¶</a></h2>
<p>Another benefit of the stub mapping in Phake is that it allows you to very easily stub multiple calls to the same
method that use different parameters. In my shopping cart I have decided to add some functionality that will allow
me to easily add multiple products that are a part of a group to the shopping cart. To facilitate this I have decided
to create a new class called <code class="docutils literal"><span class="pre">ItemGroup</span></code>. The <code class="docutils literal"><span class="pre">ItemGroup</span></code> object will be
constructed with an array of <code class="docutils literal"><span class="pre">Items</span></code>. It will have a method on the class that will add all of
the items in the group to the given cart and then the total price of items in the cart will be returned.</p>
<p>It should be noted that earlier I decided to make a small change to the <code class="docutils literal"><span class="pre">ShoppingCart::addItem()</span></code>
method to have it return the total price of items in the cart. I figured that this would be nice api level functionality
to make working with the system a little bit easier. I would like to take advantage of that change with this code.
Here&#8217;s a stub of the functionality I am considering.</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="x">/**</span>
<span class="x"> * A group of items that can be added to a cart all at the same time</span>
<span class="x"> */</span>
<span class="x">class ItemGroup</span>
<span class="x">{</span>
<span class="x">    /**</span>
<span class="x">     * @param array $items an array of Item objects</span>
<span class="x">     */</span>
<span class="x">    public function __construct(array $items)</span>
<span class="x">    {</span>
<span class="x">    }</span>

<span class="x">    /**</span>
<span class="x">     * @param ShoppingCart $cart</span>
<span class="x">     * @return money The new total value of the cart</span>
<span class="x">     */</span>
<span class="x">    public function addItemsToCart(ShoppingCart $cart)</span>
<span class="x">    {</span>
<span class="x">    }</span>
<span class="x">}</span>
</pre></div>
</div>
<p>The next test I am going to write now is going to be focusing on this new <code class="docutils literal"><span class="pre">ItemGroup::addItemsToCart()</span></code>
method. In my test&#8217;s <code class="docutils literal"><span class="pre">setUp()</span></code> method I&#8217;ll create a new instance of <code class="docutils literal"><span class="pre">ItemGroup</span></code>
which will require one or more <code class="docutils literal"><span class="pre">Item</span></code> implementations. I&#8217;ll use mocks for those. Then the actual
test case I am going to start with will be a test to assert that <code class="docutils literal"><span class="pre">ItemGroup::addItemsToCart()</span></code>
returns the new shopping cart value. I already know that I am going to need to get this value by looking at the
last return value from calls to <code class="docutils literal"><span class="pre">ShoppingCart::addItem()</span></code>. To allow for checking this I will mock
<code class="docutils literal"><span class="pre">ShoppingCart</span></code> and create three stubs for <code class="docutils literal"><span class="pre">ShoppingCart::addItem()</span></code>. Each
stub will be for a call with a different <code class="docutils literal"><span class="pre">Item</span></code>.</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="x">class ItemGroupTest extends PHPUnit\Framework\TestCase</span>
<span class="x">{</span>
<span class="x">    private ItemGroup $itemGroup;</span>
<span class="x">    private Item $item1;</span>
<span class="x">    private Item $item2;</span>
<span class="x">    private Item $item3;</span>

<span class="x">    public function setUp(): void</span>
<span class="x">    {</span>
<span class="x">        $this-&gt;item1 = Phake::mock(Item::class);</span>
<span class="x">        $this-&gt;item2 = Phake::mock(Item::class);</span>
<span class="x">        $this-&gt;item3 = Phake::mock(Item::class);</span>

<span class="x">        $this-&gt;itemGroup = new ItemGroup([ $this-&gt;item1, $this-&gt;item2, $this-&gt;item3 ]);</span>
<span class="x">    }</span>

<span class="x">    public function testAddItemsToCart()</span>
<span class="x">    {</span>
<span class="x">        $cart = Phake::mock(ShoppingCart::class);</span>
<span class="x">        Phake::when($cart)-&gt;addItem($this-&gt;item1)-&gt;thenReturn(10);</span>
<span class="x">        Phake::when($cart)-&gt;addItem($this-&gt;item2)-&gt;thenReturn(20);</span>
<span class="x">        Phake::when($cart)-&gt;addItem($this-&gt;item3)-&gt;thenReturn(30);</span>

<span class="x">        $totalCost = $this-&gt;itemGroup-&gt;addItemsToCart($cart);</span>
<span class="x">        $this-&gt;assertEquals(30, $totalCost);</span>
<span class="x">    }</span>
<span class="x">}</span>
</pre></div>
</div>
<p>In this example the <code class="docutils literal"><span class="pre">ShoppingCart::addItem()</span></code> method is being stubbed three times. Each time it
is being stubbed with a different parameter being passed to <code class="docutils literal"><span class="pre">addItem()</span></code>. This a good example of
how parameters are also checked whenever Phake looks at a mock object&#8217;s stub map for answers. The default behavior
of argument matching is again a loose equality check. Similar to how you would use the double equals operator in PHP.
The other options for argument matching are discussed further in <a class="reference internal" href="method-parameter-matchers.html#method-parameter-matchers-section"><span class="std std-ref">Method Parameter Matchers</span></a>.</p>
</div>
<div class="section" id="stubbing-consecutive-calls">
<h2>Stubbing Consecutive Calls<a class="headerlink" href="#stubbing-consecutive-calls" title="Permalink to this headline">Â¶</a></h2>
<p>The previous test was a great example for how you can make multiple stubs for a single method however in reality it
is not the best way for that particular test to be written. What if the <code class="docutils literal"><span class="pre">Item</span></code> objects in an
<code class="docutils literal"><span class="pre">ItemGroup</span></code> aren&#8217;t stored in the order they were passed in? I am needlessly binding my test
to the order in which objects are stored. Phake provides the ability to map multiple answers to the same stub. This is
done simply by chaining the answers together. I could rewrite the test from the previous chapter to utilize this
feature of Phake.</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="x">class ItemGroupTest extends PHPUnit\Framework\TestCase</span>
<span class="x">{</span>
<span class="x">    private ItemGroup $itemGroup;</span>
<span class="x">    private Item $item1;</span>
<span class="x">    private Item $item2;</span>
<span class="x">    private Item $item3;</span>

<span class="x">    public function setUp(): void</span>
<span class="x">    {</span>
<span class="x">        $this-&gt;item1 = Phake::mock(Item::class);</span>
<span class="x">        $this-&gt;item2 = Phake::mock(Item::class);</span>
<span class="x">        $this-&gt;item3 = Phake::mock(Item::class);</span>

<span class="x">        $this-&gt;itemGroup = new ItemGroup([ $this-&gt;item1, $this-&gt;item2, $this-&gt;item3 ]);</span>
<span class="x">    }</span>

<span class="x">    public function testAddItemsToCart()</span>
<span class="x">    {</span>
<span class="x">        $cart = Phake::mock(ShoppingCart::class);</span>
<span class="x">        Phake::when($cart)-&gt;addItem(Phake::anyParameters())-&gt;thenReturn(10)</span>
<span class="x">            -&gt;thenReturn(20)</span>
<span class="x">            -&gt;thenReturn(30);</span>

<span class="x">        $totalCost = $this-&gt;itemGroup-&gt;addItemsToCart($cart);</span>
<span class="x">        $this-&gt;assertEquals(30, $totalCost);</span>
<span class="x">    }</span>
<span class="x">}</span>
</pre></div>
</div>
<p>You will notice a few of differences between this example and the example in <a class="reference internal" href="#stubbing-multiple-calls"><span class="std std-ref">Stubbing Multiple Calls</span></a>. The first
difference is that there is only one call to <code class="docutils literal"><span class="pre">Phake::when()</span></code>. The second difference is that I have chained together three
calls to <code class="docutils literal"><span class="pre">thenReturn()</span></code>. The third difference is instead of passing one of my mock Item
objects I have passed the result of the <code class="docutils literal"><span class="pre">Phake::anyParameters()</span></code> method. This is a special argument
matcher in Phake that essentially says match any call to the method regardless of the number of parameters or the
value of those parameters. You can learn more about <code class="docutils literal"><span class="pre">Phake::anyParameters()</span></code> in <a class="reference internal" href="method-parameter-matchers.html#wildcard-parameters"><span class="std std-ref">Wildcard Parameters</span></a>.</p>
<p>So, this single call to <code class="docutils literal"><span class="pre">Phake::when()</span></code> is saying: &#8220;Whenever a call to <code class="docutils literal"><span class="pre">$cart-&gt;addItem()</span></code>
is made, regardless of the parameters, return 10 for the first call, 20 for the second call, and 30 for the third
call.&#8221; If you are using consecutive call stubbing and you call the method more times than you have answers set, the
last answer will continue to be returned. In this example, if <code class="docutils literal"><span class="pre">$cart-&gt;addItem()</span></code> were called a fourth
time, then 30 would be returned again.</p>
</div>
<div class="section" id="stubbing-reference-parameters">
<h2>Stubbing Reference Parameters<a class="headerlink" href="#stubbing-reference-parameters" title="Permalink to this headline">Â¶</a></h2>
<p>Occasionally you may run into code that utilizes reference parameters to provide additional output
from a method. This is not an uncommon thing to run into with legacy code. Phake provides a custom
parameter matcher (these are discussed further in <a class="reference internal" href="method-parameter-matchers.html#method-parameter-matchers-section"><span class="std std-ref">Method Parameter Matchers</span></a>)
that allows you to set reference parameters. It can be accessed using <code class="docutils literal"><span class="pre">Phake::setReference()</span></code>.
The only parameter to this matcher is the value you would like to set the reference parameter
to provided all other parameters match.</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="x">interface IValidator</span>
<span class="x">{</span>
<span class="x">    /**</span>
<span class="x">     * @parm array $data Data to validate</span>
<span class="x">     * @parm array &amp;$errors contains all validation errors if the data is not valid</span>
<span class="x">     * @return boolean True when the data is valid</span>
<span class="x">     */</span>
<span class="x">    public function validate(array $data, array &amp;$errors);</span>
<span class="x">}</span>

<span class="x">class ValidationLogger implements IValidator</span>
<span class="x">{</span>
<span class="x">    private $validator;</span>
<span class="x">    private $log;</span>

<span class="x">    public function __construct(IValidator $validator, Logger $log)</span>
<span class="x">    {</span>
<span class="x">        $this-&gt;validator = $validator;</span>
<span class="x">        $this-&gt;log = $log;</span>
<span class="x">    }</span>

<span class="x">    public function validate(array $data, array &amp;$errors)</span>
<span class="x">    {</span>
<span class="x">        if (!$this-&gt;validator-&gt;validate($data, $errors))</span>
<span class="x">        {</span>
<span class="x">            foreach ($errors as $error)</span>
<span class="x">            {</span>
<span class="x">                $this-&gt;log-&gt;info(&quot;Validation Error: {$error}&quot;);</span>
<span class="x">            }</span>

<span class="x">            return false;</span>
<span class="x">        }</span>

<span class="x">        return true;</span>
<span class="x">    }</span>
<span class="x">}</span>

<span class="x">class ValidationLoggerTest extends PHPUnit\Framework\TestCase</span>
<span class="x">{</span>
<span class="x">    public function testValidate()</span>
<span class="x">    {</span>
<span class="x">        //Mock the dependencies</span>
<span class="x">        $validator = Phake::mock(IValidator::class);</span>
<span class="x">        $log = Phake::mock(Logger::class);</span>
<span class="x">        $data = [ &#39;data1&#39; =&gt; &#39;value&#39; ];</span>
<span class="x">        $expectedErrors = [&#39;data1 is not valid&#39;];</span>

<span class="x">        //Setup the stubs (Notice the Phake::setReference()</span>
<span class="x">        Phake::when($validator)-&gt;validate($data, Phake::setReference($expectedErrors))-&gt;thenReturn(false);</span>

<span class="x">        //Instantiate the SUT</span>
<span class="x">        $validationLogger = new ValidationLogger($validator, $log);</span>

<span class="x">        //verify the validation is false and the message is logged</span>
<span class="x">        $errors = [];</span>
<span class="x">        $this-&gt;assertFalse($validationLogger-&gt;validate($data, $errors));</span>
<span class="x">        Phake::verify($log)-&gt;info(&#39;Validation Error: data1 is not valid&#39;);</span>
<span class="x">    }</span>
<span class="x">}</span>
</pre></div>
</div>
<p>In the example above, I am testing a new class I have created called <code class="docutils literal"><span class="pre">ValidationLogger</span></code>.
It is a decorator for other implementations of <code class="docutils literal"><span class="pre">IValidator</span></code> that allows adding
logging to any other validator. The <code class="docutils literal"><span class="pre">IValidator::validate()</span></code> method will always
return an array of errors into the second parameter (a reference parameter) provided to the method.
These errors are what my logger is responsible for logging. So in order for my test to work properly,
I will need to be able to set that second parameter as a part of my stubbing call.</p>
<p>In the call to <code class="docutils literal"><span class="pre">Phake::when($validator)-&gt;validate()</span></code> I have passed a call to
<code class="docutils literal"><span class="pre">Phake::setReference()</span></code> as the second parameter. This is causing the mock
implementation of <code class="docutils literal"><span class="pre">IValidator</span></code> to set <code class="docutils literal"><span class="pre">$errors</span></code> in
<code class="docutils literal"><span class="pre">ValidationLogger::validate()</span></code> to the array specified by <code class="docutils literal"><span class="pre">$expectedErrors</span></code>.
This allows me to quickly and easily validate that I am actually logging the errors returned back
in the reference parameter.</p>
<p>By default <code class="docutils literal"><span class="pre">Phake::setReference()</span></code> will always return true regardless of the
parameter initially passed in. If you would like to only set a reference parameter when that reference
parameter was passed in as a certain value you can use the <code class="docutils literal"><span class="pre">when()</span></code> modifier.
This takes a single parameter matcher as an argument. Below,
you will see that the test has been modified to call <code class="docutils literal"><span class="pre">when()</span></code> on the result
of <cite>Phake::setReference()`</cite>. This modification will cause the reference parameter
to be set only if the $errors parameter passed to <code class="docutils literal"><span class="pre">IValidator::validate()</span></code>
is initially passed as an empty array.</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="x">class ValidationLoggerTest extends PHPUnit\Framework\TestCase</span>
<span class="x">{</span>
<span class="x">    public function testValidate()</span>
<span class="x">    {</span>
<span class="x">        //Mock the dependencies</span>
<span class="x">        $validator = Phake::mock(IValidator::class);</span>
<span class="x">        $log = Phake::mock(Logger::class);</span>
<span class="x">        $data = [ &#39;data1&#39; =&gt; &#39;value&#39; ];</span>
<span class="x">        $expectedErrors = [ &#39;data1 is not valid&#39; ];</span>

<span class="x">        //Setup the stubs (Notice the Phake::setReference()</span>
<span class="x">        Phake::when($validator)-&gt;validate($data, Phake::setReference($expectedErrors)-&gt;when([])-&gt;thenReturn(false);</span>

<span class="x">        //Instantiate the SUT</span>
<span class="x">        $validationLogger = new ValidationLogger($validator, $log);</span>

<span class="x">        //verify the validation is false and the message is logged</span>
<span class="x">        $errors = [];</span>
<span class="x">        $this-&gt;assertFalse($validationLogger-&gt;validate($data, $errors));</span>
<span class="x">        Phake::verify($log)-&gt;info(&#39;Validation Error: data1 is not valid&#39;);</span>
<span class="x">    }</span>
<span class="x">}</span>
</pre></div>
</div>
<p>Please note, when you are using <code class="docutils literal"><span class="pre">Phake::setReference()</span></code> you still must provide
an answer for the stub. If you use this function and your reference parameter is never changed,
that is generally the most common reason.</p>
</div>
<div class="section" id="partial-mocks">
<span id="id3"></span><h2>Partial Mocks<a class="headerlink" href="#partial-mocks" title="Permalink to this headline">Â¶</a></h2>
<p>When testing legacy code, if you find that the majority of the methods in the mock are using the <code class="docutils literal"><span class="pre">thenCallParent()</span></code>
answer, you may find it easier to just use a partial mock in Phake. Phake partial mocks also allow you to call the
actual constructor of the class being mocked. They are created using <code class="docutils literal"><span class="pre">Phake::partialMock()</span></code>. Like <code class="docutils literal"><span class="pre">Phake::mock()</span></code>,
the first parameter is the name of the class that you are mocking. However, you can pass additional parameters that
will then be passed as the respective parameters to that classâ constructor. The other notable feature of a partial
mock in Phake is that its default answer is to pass the call through to the parent as if you were using
<code class="docutils literal"><span class="pre">thenCallParent()</span></code>.</p>
<p>Consider the following class that has a method that simply returns the value passed into the constructor.</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="x">class MyClass</span>
<span class="x">{</span>
<span class="x">    private $value;</span>

<span class="x">    public __construct($value)</span>
<span class="x">    {</span>
<span class="x">        $this-&gt;value = $value;</span>
<span class="x">    }</span>

<span class="x">    public function foo()</span>
<span class="x">    {</span>
<span class="x">        return $this-&gt;value;</span>
<span class="x">    }</span>
<span class="x">}</span>
</pre></div>
</div>
<p>Using <code class="docutils literal"><span class="pre">Phake::partialMock()</span></code> you can instantiate a mock object that will allow this object to function
as designed while still allowing verification as well as selective stubbing of certain calls.
Below is an example that shows the usage of <code class="docutils literal"><span class="pre">Phake::partialMock()</span></code>.</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="x">class MyClassTest extends PHPUnit\Framework\TestCase</span>
<span class="x">{</span>
<span class="x">    public function testCallingParent()</span>
<span class="x">    {</span>
<span class="x">        $mock = Phake::partialMock(MyClass::class, 42);</span>

<span class="x">        $this-&gt;assertEquals(42, $mock-&gt;foo());</span>
<span class="x">    }</span>
<span class="x">}</span>
</pre></div>
</div>
<p>Again, partial mocks should not be used when you are testing new code. If you find yourself using them be sure to
inspect your design to make sure that the class you are creating a partial mock for is not doing too much.</p>
</div>
<div class="section" id="setting-default-stubs">
<h2>Setting Default Stubs<a class="headerlink" href="#setting-default-stubs" title="Permalink to this headline">Â¶</a></h2>
<p>You can also change the default stubbing for mocks created with <code class="docutils literal"><span class="pre">Phake::mock()</span></code>. This is done by using the second
parameter to <code class="docutils literal"><span class="pre">Phake::mock()</span></code> in conjunction with the <code class="docutils literal"><span class="pre">Phake::ifUnstubbed()</span></code> method. The second parameter to
<code class="docutils literal"><span class="pre">Phake::mock()</span></code> is reserved for configuring the behavior of an individual mock. <code class="docutils literal"><span class="pre">Phake::ifUnstubbed()</span></code> allows you
to specify any of the matchers mentioned above as the default answer if any method invocation is not explicitly
stubbed. If this configuration directive is not provided then the method will return NULL by default. An example of
this can be seen below.</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="x">class MyClassTest extends PHPUnit\Framework\TestCase</span>
<span class="x">{</span>
<span class="x">    public function testDefaultStubs()</span>
<span class="x">    {</span>
<span class="x">        $mock = Phake::mock(MyClass::class, Phake::ifUnstubbed()-&gt;thenReturn(42));</span>

<span class="x">        $this-&gt;assertEquals(42, $mock-&gt;foo());</span>
<span class="x">    }</span>
<span class="x">}</span>
</pre></div>
</div>
</div>
<div class="section" id="stubbing-magic-methods">
<h2>Stubbing Magic Methods<a class="headerlink" href="#stubbing-magic-methods" title="Permalink to this headline">Â¶</a></h2>
<p>Most magic methods can be stubbed using the method name just like you would any other method. The one exception to this
is the <code class="docutils literal"><span class="pre">__call()</span></code> method. This method is overwritten on each mock already to allow for the fluent api that Phake
utilizes. If you want to stub a particular invocation of <code class="docutils literal"><span class="pre">__call()</span></code> you can create a stub for the method you are
targetting in the first parameter to <code class="docutils literal"><span class="pre">__call()</span></code>.</p>
<p>Consider the following class.</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="x">class MagicClass</span>
<span class="x">{</span>
<span class="x">    public function __call($method, $args)</span>
<span class="x">    {</span>
<span class="x">        return &#39;__call&#39;;</span>
<span class="x">    }</span>
<span class="x">}</span>
</pre></div>
</div>
<p>You could stub an invocation of the <code class="docutils literal"><span class="pre">__call()</span></code> method through a userspace call to <code class="docutils literal"><span class="pre">magicCall()</span></code> with the following code.</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="x">class MagicClassTest extends PHPUnit\Framework\TestCase</span>
<span class="x">{</span>
<span class="x">    public function testMagicCall()</span>
<span class="x">    {</span>
<span class="x">        $mock = Phake::mock(MagicClass::class);</span>

<span class="x">        Phake::when($mock)-&gt;magicCall()-&gt;thenReturn(42);</span>

<span class="x">        $this-&gt;assertEquals(42, $mock-&gt;magicCall());</span>
<span class="x">    }</span>
<span class="x">}</span>
</pre></div>
</div>
<p>If for any reason you need to explicitly stub calls to <code class="docutils literal"><span class="pre">__call()</span></code> then you can use <code class="docutils literal"><span class="pre">Phake::whenCallMethodWith()</span></code>.
The matchers passed to <code class="docutils literal"><span class="pre">Phake::whenCallMethod()</span></code> will be matched to the method name and array of arguments similar to
what you would expect to be passed to a <code class="docutils literal"><span class="pre">__call()</span></code> method. You can also use Phake::anyParameters() instead.</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="x">class MagicClassTest extends PHPUnit\Framework\TestCase</span>
<span class="x">{</span>
<span class="x">    public function testMagicCall()</span>
<span class="x">    {</span>
<span class="x">        $mock = Phake::mock(MagicClass::class);</span>

<span class="x">        Phake::whenCallMethodWith(&#39;magicCall&#39;, [])-&gt;isCalledOn($mock)-&gt;thenReturn(42);</span>

<span class="x">        $this-&gt;assertEquals(42, $mock-&gt;magicCall());</span>
<span class="x">    }</span>
<span class="x">}</span>
</pre></div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Method Stubbing</a><ul>
<li><a class="reference internal" href="#how-phake-when-works">How Phake::when() Works</a></li>
<li><a class="reference internal" href="#overwriting-existing-stubs">Overwriting Existing Stubs</a></li>
<li><a class="reference internal" href="#resetting-a-mock-s-stubs">Resetting A Mock&#8217;s Stubs</a></li>
<li><a class="reference internal" href="#stubbing-multiple-calls">Stubbing Multiple Calls</a></li>
<li><a class="reference internal" href="#stubbing-consecutive-calls">Stubbing Consecutive Calls</a></li>
<li><a class="reference internal" href="#stubbing-reference-parameters">Stubbing Reference Parameters</a></li>
<li><a class="reference internal" href="#partial-mocks">Partial Mocks</a></li>
<li><a class="reference internal" href="#setting-default-stubs">Setting Default Stubs</a></li>
<li><a class="reference internal" href="#stubbing-magic-methods">Stubbing Magic Methods</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="mocks.html"
                        title="previous chapter">Creating Mocks</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="method-verification.html"
                        title="next chapter">Method Verification</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/method-stubbing.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="method-verification.html" title="Method Verification"
             >next</a> |</li>
        <li class="right" >
          <a href="mocks.html" title="Creating Mocks"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Phake - PHP Mocking Framework 4.0.0 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2010-2021, Mike Lively &lt;m@digitalsandwich.com&gt;.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.9.
    </div>
  </body>
</html>